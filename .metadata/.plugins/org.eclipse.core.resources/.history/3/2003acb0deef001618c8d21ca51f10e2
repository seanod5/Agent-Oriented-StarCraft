agent TerranSCV {
	module EIS eis;
	module Console C;
	module Prelude P;
	
	types status {
		formula health(int);
		formula shield(int);
		formula energy(int);
		formula x(int);
		formula y(int);
	}
	
	types condition {
		formula moving(boolean);
		formula idle(boolean);
		formula carrying(boolean);
		formula constructing(boolean);
	}
	
	types model {
		formula availableMinerals(list);
		formula availableVespene(list);
		formula content(string);
		formula constructSitesX(list);
		formula constructSitesY(list);
	}
	
	initial !init();
//	initial health(60);
//	initial shield(0);
//	initial energy(0);
	initial condition([]);
	initial availableMinerals([]);
	initial availableVespene([]);
	initial constructSitesX([]);
	initial constructSitesY([]);
	
	rule +!init() {
		eis.join("starcraft");
		eis.link();
		C.println("SCV linked.");
		
		!gatherMinerals();
	}
	
	rule +!gatherMinerals() : availableMinerals(list L) {
		int ID = P.valueAsInt(L, 0);
		eis.gather(ID);
	}
	
	rule +!gatherMinerals() {
		!gatherMinerals();
	}
	
	rule +!gatherVespene() : availableVespene(list L) {
		int ID = P.valueAsInt(L, 0);
		eis.gather(ID);
	}
	
	rule +!buildStructure(string structure, string sender) : constructSitesX(list sitesX) & constructSitesY(list sitesY) {
		int x = P.headAsInt(sitesX);
		int y = P.headAsInt(sitesY);
		list newX = sitesX;
		list newY = sitesY;
		eis.build(structure, x, y);
		wait(constructing(false));
		send(inform, sender, content("Supply Depot Built"));
		!gatherMinerals();
	}
	
	rule +$eis.event(mineralField(int ID, int resources, int group, int x, int y)) : availableMinerals(list prev) {
		list new = prev;
		P.add(new, ID);
		-availableMinerals(prev);
		+availableMinerals(new);
	}
	
	rule +$eis.event(vespeneGeyser(int ID, int resources, int group, int x, int y)) : availableVespene(list prev) {
		list new = prev;
		P.add(new, ID);
		-availableVespene(prev);
		+availableVespene(new);
	}
	
	rule +$eis.event(constructionSite(int x, int y)) : constructSitesX(list prevX) & constructSitesY(list prevY) {
		list newX = prevX;
		list newY = prevY;
		P.add(newX, x);
		P.add(newY, y);
		-constructSitesX(prevX);
		+constructSitesX(newX);
		-constructSitesY(prevY);
		+constructSitesY(newY);
	}
	
	rule +$eis.event(status(int health, int shield, int energy, list conditions, int x, int y)) : constructing(boolean constructing) {
		boolean flag = false;
		forall(string condition : conditions) {
			if(condition == "constructing") {
				flag = true;
			}
		}
		
		C.println("Status event working.");
		
		if((flag == true) & (constructing == false)) {
			-constructing(false);
			+constructing(true);
			C.println("Construction begun");
		}
		else if ((flag == false) & (constructing == true)) {
			-constructing(true);
			+constructing(false);
			C.println("Construction completed");
		}
		
		C.println("Beliefs should be updated");
	}
	
	rule @message(inform, string sender, content(string content)) {
		C.println("Message received from " + sender + ", building " + content);
		!buildStructure(content, sender);
	}
}
